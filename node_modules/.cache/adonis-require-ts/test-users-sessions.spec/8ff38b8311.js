"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("./../../database/factories/index");
const japa_1 = __importDefault(require("japa"));
const supertest_1 = __importDefault(require("supertest"));
const Database_1 = __importDefault(global[Symbol.for('ioc.use')]("Adonis/Lucid/Database"));
const BASE_URL = `http://${process.env.HOST}:${process.env.PORT}`;
japa_1.default.group('Session', (group) => {
    (0, japa_1.default)('it should authentication an user', async (assert) => {
        const plainPassword = 'test';
        const { id, email } = await index_1.UserFactory.merge({ password: plainPassword }).create();
        const { body } = await (0, supertest_1.default)(BASE_URL)
            .post('/sessions')
            .send({ email, password: plainPassword })
            .expect(201);
        assert.isDefined(body.user, 'User undefined');
        assert.equal(body.user.id, id);
    });
    (0, japa_1.default)('it should return an api token when session is created', async (assert) => {
        const plainPassword = 'test';
        const { id, email } = await index_1.UserFactory.merge({ password: plainPassword }).create();
        const { body } = await (0, supertest_1.default)(BASE_URL)
            .post('/sessions')
            .send({ email, password: plainPassword })
            .expect(201);
        assert.isDefined(body.token, 'Token undefined');
        assert.equal(body.user.id, id);
    });
    (0, japa_1.default)('it should return 400 when credentials are not provided', async (assert) => {
        const { body } = await (0, supertest_1.default)(BASE_URL)
            .post('/sessions')
            .send({})
            .expect(400);
        assert.equal(body.code, 'BAD_REQUEST');
        assert.equal(body.status, 400);
    });
    (0, japa_1.default)('it should return 400 when credentials are invalid', async (assert) => {
        const { email } = await index_1.UserFactory.create();
        const { body } = await (0, supertest_1.default)(BASE_URL)
            .post('/sessions')
            .send({ email, password: 'test' })
            .expect(400);
        assert.equal(body.code, 'BAD_REQUEST');
        assert.equal(body.status, 400);
        assert.equal(body.message, 'invalid credentials');
    });
    (0, japa_1.default)('it should return 200 when user signs out', async (assert) => {
        const plainPassword = 'test';
        const { id, email } = await index_1.UserFactory.merge({ password: plainPassword }).create();
        const { body } = await (0, supertest_1.default)(BASE_URL)
            .post('/sessions')
            .send({ email, password: plainPassword })
            .expect(201);
        const apiToken = body.token;
        await (0, supertest_1.default)(BASE_URL)
            .delete('/sessions')
            .set('Authorization', `Bearer ${apiToken.token}`)
            .expect(200);
    });
    (0, japa_1.default)('it should revoke token when user signs out', async (assert) => {
        const plainPassword = 'test';
        const { email } = await index_1.UserFactory.merge({ password: plainPassword }).create();
        const { body } = await (0, supertest_1.default)(BASE_URL)
            .post('/sessions')
            .send({ email, password: plainPassword })
            .expect(201);
        const apiToken = body.token;
        await (0, supertest_1.default)(BASE_URL)
            .delete('/sessions')
            .set('Authorization', `Bearer ${apiToken.token}`)
            .expect(200);
        const token = await Database_1.default.query()
            .select('*')
            .from('api_tokens');
        assert.isEmpty(token);
    });
    group.beforeEach(async () => {
        await Database_1.default.beginGlobalTransaction();
    });
    group.afterEach(async () => {
        await Database_1.default.rollbackGlobalTransaction();
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Vzc2lvbnMuc3BlYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInNlc3Npb25zLnNwZWMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSw0REFBOEQ7QUFDOUQsZ0RBQXVCO0FBQ3ZCLDBEQUFpQztBQUNqQywyRkFBaUQ7QUFFakQsTUFBTSxRQUFRLEdBQUcsVUFBVSxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxDQUFBO0FBRWpFLGNBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFLENBQUMsS0FBSyxFQUFFLEVBQUU7SUFDOUIsSUFBQSxjQUFJLEVBQUMsa0NBQWtDLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxFQUFFO1FBQ3hELE1BQU0sYUFBYSxHQUFHLE1BQU0sQ0FBQTtRQUM1QixNQUFNLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxHQUFHLE1BQU0sbUJBQVcsQ0FBQyxLQUFLLENBQUMsRUFBRSxRQUFRLEVBQUUsYUFBYSxFQUFFLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQTtRQUNuRixNQUFNLEVBQUUsSUFBSSxFQUFFLEdBQUcsTUFBTSxJQUFBLG1CQUFTLEVBQUMsUUFBUSxDQUFDO2FBQ3ZDLElBQUksQ0FBQyxXQUFXLENBQUM7YUFDakIsSUFBSSxDQUFDLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxhQUFhLEVBQUUsQ0FBQzthQUN4QyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUE7UUFFZCxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQTtRQUM3QyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFBO0lBQ2hDLENBQUMsQ0FBQyxDQUFBO0lBV0YsSUFBQSxjQUFJLEVBQUMsdURBQXVELEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxF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c0JBQXNCLEVBQUUsQ0FBQTtJQUN6QyxDQUFDLENBQUMsQ0FBQTtJQUNGLEtBQUssQ0FBQyxTQUFTLENBQUMsS0FBSyxJQUFJLEVBQUU7UUFDekIsTUFBTSxrQkFBUSxDQUFDLHlCQUF5QixFQUFFLENBQUE7SUFDNUMsQ0FBQyxDQUFDLENBQUE7QUFDSixDQUFDLENBQUMsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFVzZXJGYWN0b3J5IH0gZnJvbSAnLi8uLi8uLi9kYXRhYmFzZS9mYWN0b3JpZXMvaW5kZXgnXG5pbXBvcnQgdGVzdCBmcm9tICdqYXBhJ1xuaW1wb3J0IHN1cGVydGVzdCBmcm9tICdzdXBlcnRlc3QnXG5pbXBvcnQgRGF0YWJhc2UgZnJvbSAnQGlvYzpBZG9uaXMvTHVjaWQvRGF0YWJhc2UnXG5cbmNvbnN0IEJBU0VfVVJMID0gYGh0dHA6Ly8ke3Byb2Nlc3MuZW52LkhPU1R9OiR7cHJvY2Vzcy5lbnYuUE9SVH1gXG5cbnRlc3QuZ3JvdXAoJ1Nlc3Npb24nLCAoZ3JvdXApID0+IHtcbiAgdGVzdCgnaXQgc2hvdWxkIGF1dGhlbnRpY2F0aW9uIGFuIHVzZXInLCBhc3luYyAoYXNzZXJ0KSA9PiB7XG4gICAgY29uc3QgcGxhaW5QYXNzd29yZCA9ICd0ZXN0J1xuICAgIGNvbnN0IHsgaWQsIGVtYWlsIH0gPSBhd2FpdCBVc2VyRmFjdG9yeS5tZXJnZSh7IHBhc3N3b3JkOiBwbGFpblBhc3N3b3JkIH0pLmNyZWF0ZSgpXG4gICAgY29uc3QgeyBib2R5IH0gPSBhd2FpdCBzdXBlcnRlc3QoQkFTRV9VUkwpXG4gICAgICAucG9zdCgnL3Nlc3Npb25zJylcbiAgICAgIC5zZW5kKHsgZW1haWwsIHBhc3N3b3JkOiBwbGFpblBhc3N3b3JkIH0pXG4gICAgICAuZXhwZWN0KDIwMSlcblxuICAgIGFzc2VydC5pc0RlZmluZWQoYm9keS51c2VyLCAnVXNlciB1bmRlZmluZWQnKVxuICAgIGFzc2VydC5lcXVhbChib2R5LnVzZXIuaWQsIGlkKVxuICB9KVxuXG4gIC8qKlxuICAgKlxuICAgKiB7XG4gICAqICB1c2VyOiB7XG4gICAqICB9LFxuICAgKiAgdG9rZW46IHtcbiAgICogIH1cbiAgICogfVxuICAgKi9cbiAgdGVzdCgnaXQgc2hvdWxkIHJldHVybiBhbiBhcGkgdG9rZW4gd2hlbiBzZXNzaW9uIGlzIGNyZWF0ZWQnLCBhc3luYyAoYXNzZXJ0KSA9PiB7XG4gICAgY29uc3QgcGxhaW5QYXNzd29yZCA9ICd0ZXN0J1xuICAgIGNvbnN0IHsgaWQsIGVtYWlsIH0gPSBhd2FpdCBVc2VyRmFjdG9yeS5tZXJnZSh7IHBhc3N3b3JkOiBwbGFpblBhc3N3b3JkIH0pLmNyZWF0ZSgpXG4gICAgY29uc3QgeyBib2R5IH0gPSBhd2FpdCBzdXBlcnRlc3QoQkFTRV9VUkwpXG4gICAgICAucG9zdCgnL3Nlc3Npb25zJylcbiAgICAgIC5zZW5kKHsgZW1haWwsIHBhc3N3b3JkOiBwbGFpblBhc3N3b3JkIH0pXG4gICAgICAuZXhwZWN0KDIwMSlcblxuICAgIGFzc2VydC5pc0RlZmluZWQoYm9keS50b2tlbiwgJ1Rva2VuIHVuZGVmaW5lZCcpXG4gICAgYXNzZXJ0LmVxdWFsKGJvZHkudXNlci5pZCwgaWQpXG4gIH0pXG5cbiAgdGVzdCgnaXQgc2hvdWxkIHJldHVybiA0MDAgd2hlbiBjcmVkZW50aWFscyBhcmUgbm90IHByb3ZpZGVkJywgYXN5bmMgKGFzc2VydCkgPT4ge1xuICAgIGNvbnN0IHsgYm9keSB9ID0gYXdhaXQgc3VwZXJ0ZXN0KEJBU0VfVVJMKVxuICAgICAgLnBvc3QoJy9zZXNzaW9ucycpXG4gICAgICAuc2VuZCh7fSlcbiAgICAgIC5leHBlY3QoNDAwKVxuXG4gICAgYXNzZXJ0LmVxdWFsKGJvZHkuY29kZSwgJ0JBRF9SRVFVRVNUJylcbiAgICBhc3NlcnQuZXF1YWwoYm9keS5zdGF0dXMsIDQwMClcbiAgfSlcblxuICB0ZXN0KCdpdCBzaG91bGQgcmV0dXJuIDQwMCB3aGVuIGNyZWRlbnRpYWxzIGFyZSBpbnZhbGlkJywgYXN5bmMgKGFzc2VydCkgPT4ge1xuICAgIGNvbnN0IHsgZW1haWwgfSA9IGF3YWl0IFVzZXJGYWN0b3J5LmNyZWF0ZSgpXG4gICAgY29uc3QgeyBib2R5IH0gPSBhd2FpdCBzdXBlcnRlc3QoQkFTRV9VUkwpXG4gICAgICAucG9zdCgnL3Nlc3Npb25zJylcbiAgICAgIC5zZW5kKHsgZW1haWwsIHBhc3N3b3JkOiAndGVzdCcgfSlcbiAgICAgIC5leHBlY3QoNDAwKVxuXG4gICAgYXNzZXJ0LmVxdWFsKGJvZHkuY29kZSwgJ0JBRF9SRVFVRVNUJylcbiAgICBhc3NlcnQuZXF1YWwoYm9keS5zdGF0dXMsIDQwMClcbiAgICBhc3NlcnQuZXF1YWwoYm9keS5tZXNzYWdlLCAnaW52YWxpZCBjcmVkZW50aWFscycpXG4gIH0pXG5cbiAgdGVzdCgnaXQgc2hvdWxkIHJldHVybiAyMDAgd2hlbiB1c2VyIHNpZ25zIG91dCcsIGFzeW5jIChhc3NlcnQpID0+IHtcbiAgICBjb25zdCBwbGFpblBhc3N3b3JkID0gJ3Rlc3QnXG4gICAgY29uc3QgeyBpZCwgZW1haWwgfSA9IGF3YWl0IFVzZXJGYWN0b3J5Lm1lcmdlKHsgcGFzc3dvcmQ6IHBsYWluUGFzc3dvcmQgfSkuY3JlYXRlKClcbiAgICBjb25zdCB7IGJvZHkgfSA9IGF3YWl0IHN1cGVydGVzdChCQVNFX1VSTClcbiAgICAgIC5wb3N0KCcvc2Vzc2lvbnMnKVxuICAgICAgLnNlbmQoeyBlbWFpbCwgcGFzc3dvcmQ6IHBsYWluUGFzc3dvcmQgfSlcbiAgICAgIC5leHBlY3QoMjAxKVxuXG4gICAgY29uc3QgYXBpVG9rZW4gPSBib2R5LnRva2VuXG5cbiAgICBhd2FpdCBzdXBlcnRlc3QoQkFTRV9VUkwpXG4gICAgICAuZGVsZXRlKCcvc2Vzc2lvbnMnKVxuICAgICAgLnNldCgnQXV0aG9yaXphdGlvbicsIGBCZWFyZXIgJHthcGlUb2tlbi50b2tlbn1gKVxuICAgICAgLmV4cGVjdCgyMDApXG4gIH0pXG5cbiAgdGVzdCgnaXQgc2hvdWxkIHJldm9rZSB0b2tlbiB3aGVuIHVzZXIgc2lnbnMgb3V0JywgYXN5bmMgKGFzc2VydCkgPT4ge1xuICAgIGNvbnN0IHBsYWluUGFzc3dvcmQgPSAndGVzdCdcbiAgICBjb25zdCB7IGVtYWlsIH0gPSBhd2FpdCBVc2VyRmFjdG9yeS5tZXJnZSh7IHBhc3N3b3JkOiBwbGFpblBhc3N3b3JkIH0pLmNyZWF0ZSgpXG4gICAgY29uc3QgeyBib2R5IH0gPSBhd2FpdCBzdXBlcnRlc3QoQkFTRV9VUkwpXG4gICAgICAucG9zdCgnL3Nlc3Npb25zJylcbiAgICAgIC5zZW5kKHsgZW1haWwsIHBhc3N3b3JkOiBwbGFpblBhc3N3b3JkIH0pXG4gICAgICAuZXhwZWN0KDIwMSlcblxuICAgIGNvbnN0IGFwaVRva2VuID0gYm9keS50b2tlblxuXG4gICAgYXdhaXQgc3VwZXJ0ZXN0KEJBU0VfVVJMKVxuICAgICAgLmRlbGV0ZSgnL3Nlc3Npb25zJylcbiAgICAgIC5zZXQoJ0F1dGhvcml6YXRpb24nLCBgQmVhcmVyICR7YXBpVG9rZW4udG9rZW59YClcbiAgICAgIC5leHBlY3QoMjAwKVxuXG4gICAgY29uc3QgdG9rZW4gPSBhd2FpdCBEYXRhYmFzZS5xdWVyeSgpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5mcm9tKCdhcGlfdG9rZW5zJylcblxuICAgIGFzc2VydC5pc0VtcHR5KHRva2VuKVxuICB9KVxuXG4gIGdyb3VwLmJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IERhdGFiYXNlLmJlZ2luR2xvYmFsVHJhbnNhY3Rpb24oKVxuICB9KVxuICBncm91cC5hZnRlckVhY2goYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IERhdGFiYXNlLnJvbGxiYWNrR2xvYmFsVHJhbnNhY3Rpb24oKVxuICB9KVxufSlcbiJdfQ==